//{$UNDEF SCRIPT_ID}{$DEFINE SCRIPT_ID := ''}
//{$UNDEF SCRIPT_REVISION}{$DEFINE SCRIPT_REVISION := '0.01'}
{$DEFINE SRL_ENABLE_REMOTEINPUT}
{$IFDEF WINDOWS}{$DEFINE SCRIPT_GUI}{$ENDIF}
{$I SRL-T/osr.simba}
{$I WaspLib/osr.simba}
// Rev 0.01

// Shoutout to Prush, I learnt alot from reading his scripts which then evolved into this chaos....
// Thanks for Torwent and Flight who I also pulled little bits from here and there much love guys <3
// It's my first script ever so it will be messy but at least it works... well for me it does....

//=======================SCRIPT SETTINGS========================
begin
  Login.PlayerIndex := 0;
  WLSettings.Antiban.Chat := False;
  WLSettings.Antiban.GameTabs := False;
  WLSettings.Antiban.Bank := False;
  WLSettings.RemoteInput.Enabled := True;
end;

var
BURYBONES: Boolean = False;
DROPFEATHERS: Boolean = False;
//==============================================================

type
  SnareState = (SETUP, SUCCESSFUL, FAILED, FALLEN);

  Snare = record
    Position: TPoint;
    State: SnareState;
  end;

  EState = (
    SETUP_SNARE,
    WALK_NEWSPOT,
    CHECK_SNARE,
    BURY_BONES,
    CLEAR_INV,
    WAIT_STATE
  );

  TScript = record (TBaseWalkerScript)
    State: EState;
    Snares: array of Snare;

    RawMeat,
    Birdsnare,
    Bones,
    Feather: TRSItem;

    BirdSnareSetup,
    SuccessSnare,
    FailSnare: TRSObject;

    SnarePos,
    BirdAreaPoly: TPointArray;

    BirdSnareSetupCol,
    BirdSnareSetupCol2,
    SuccessSnareCol,
    SprungSnareCol: TCTS2Color;

    MyPos: TPoint;

    StartXP,
    HunterLevel,
    GainedXP,
    SuccessfulCatches,
    BonesBuried,
    SnareCount: Int32;

    RunTime: TStopWatch;
  end;
Var
  BonesBuried: Int32;
  SuccessfulCatches: Int32;
//  Bot: TScript;

procedure TAntiban.Setup(); override;
begin
  Self.Skills := [ERSSkill.TOTAL, ERSSkill.HUNTER];
  Self.MinZoom := 45;
  Self.MaxZoom := 55;

  inherited;
end;

procedure TMufasaBitmap.DrawTextOutline(text: String; p: TPoint; color: Int32; darkShadow: Boolean = True; size: Int32 = 1);
var
  shadowColor, i: Int32;

begin
  if darkShadow then shadowColor := 1
  else shadowColor := $FFFFFF;
  for i := 1 to size do                                        //why am i so fuzy :(
  begin
    Self.DrawText(text, [p.X + i, p.Y + i], shadowColor);
    Self.DrawText(text, [p.X + i, p.Y - i], shadowColor);
    Self.DrawText(text, [p.X - i, p.Y + i], shadowColor);
    Self.DrawText(text, [p.X - i, p.Y - i], shadowColor);

    Self.DrawText(text, [p.X + i, p.Y], shadowColor);
    Self.DrawText(text, [p.X, p.Y + i], shadowColor);
    Self.DrawText(text, [p.X - i, p.Y], shadowColor);
    Self.DrawText(text, [p.X, p.Y - i], shadowColor);
  end;
  Self.DrawText(text, p, color);
end;

procedure ProgressReport.DrawBackground(strArray: TStringArray; fontColor: Int32); static; override;
begin
  if not ProgressReport.IsSetup then
  begin
    if strArray = [] then
      Exit;

    ProgressReport.BGImg.setFontSize(22);
    ProgressReport.BGImg.DrawTextOutline(ScriptName.Before('.simba').Replace('_', ' ').Capitalize(), [Round(ProgressReport.BGImg.GetWidth()/2) + 25, 5], FontColor, True, 2);

    ProgressReport.BGImg.setFontSize(18);

    if WLSettings.RemoteInput.HUDTransparent then
      ProgressReport.BGImg.DrawTextOutline(strArray[High(strArray)], [10, 130], fontColor, True, 2)
    else
      ProgressReport.BGImg.DrawTextOutline(strArray[High(strArray)], [10, 130], fontColor, True, 2);
    ProgressReport.IsSetup := True;
  end;

  ProgressReport.ClientImg.DrawBitmap(ProgressReport.BGImg, ProgressReport.TopLeft);
end;

procedure ProgressReport.DrawProgress(strArray: TStringArray; fontColor: Int32); static; override;
var
  p, q: TPoint;
  i: Int32;
begin
  p := [ProgressReport.TopLeft.X + 10, ProgressReport.TopLeft.Y + 40];
  if WLSettings.RemoteInput.HUDTransparent then
    p.Y -= 12;
  q := [Round(Chat.Bounds().Width()/2) + 20, p.Y];

  fontColor -= $C8D100;

  for i := 0 to High(strArray) - 1 do
  begin
    if Frac(i/2) = 0 then
    begin
      ClientImg.DrawTextOutline(strArray[i], p, fontColor, True, 2);
      p.Y += 17;
    end
    else
    begin
      ClientImg.DrawTextOutline(strArray[i], q, fontColor, True, 2);
      q.Y += 17;
    end;
  end;

  ProgressReport.PreviousStrArray := strArray;
  if WLSettings.RemoteInput.HUDTransparent then
    ProgressReport.ClientImg.DrawBoxFilled(ProgressReport.UsernameBox, False, $819DAC);
end;

function TBaseScript.BuildTextReport(): TStringArray; override;
var
  elapsedTime: UInt64;
begin
  if Self.Action = Self.PreviousAction then
      Exit;

  Self.DebugLn(Self.Action, Self.ExtraInfo);  //add action and extra info the the log.
  elapsedTime := Self.TimeRunning.ElapsedTime();

//  Result += ' Action        : ' + Self.Action;

//  Result += ' Runtime       : ' + SRL.MsToTime(elapsedTime, Time_Short).Trim();

//  Result += ' Runes Crafted : ' + SRL.FormatNumber(RUNESCRAFTED, 2);
//  Result += ' Runes/Hour    : ' + SRL.FormatNumber(NumberPerHour(RUNESCRAFTED, elapsedTime), 2);

//  Result += ' Total Trips   : ' + ToStr(Self.TotalActions);
  if Self.ActionLimit > -1 then
//    Result[High(Result)] += '/' + ToStr(Self.ActionLimit);

//  Result += ' Trips/Hour    : ' + ToStr(NumberPerHour(Self.TotalActions, elapsedTime));

//  Result += ' Total Exp     : ' + SRL.FormatNumber(WL.XP.Previous - WL.XP.Start, 2);
//  Result += ' Exp/Hour      : ' + SRL.FormatNumber(NumberPerHour(WL.XP.Previous - WL.XP.Start, elapsedTime), 2);

//  Result += ' Total Profit  : ' + SRL.FormatNumber(Self.TotalProfit, 2);
//  Result += ' Profit/Hour   : ' + SRL.FormatNumber(NumberPerHour(Self.TotalProfit, elapsedTime), 2);

//  Result += ' ' + Self.Welcome + ' waspscripts.com';
end;

procedure TScript.Init(MaxActions: Int32; MaxTime: Int64); override;
begin
  Self.RunTime.Start();
  Self.DoAntiban();
  Self.RSW.Setup([RSRegions.PISCATORIS]);
  Self.RSW.AdaptiveWalk:= False;
  Self.RSW.ScreenWalk := True;
  MyPos := Self.RSW.GetMyPos();
  Mouse.Speed := Random(16, 21);
  Mouse.Distribution := MOUSE_DISTRIBUTION_GAUSS;
  Mouse.MissChance := Random(5, 10);
  Self.SnareCount := 0;
  SetLength(Self.Snares, 0);

  if Options.GetBrightnessLevel < 100 then
    Options.SetMaxBrightness;
  Options.SetZoomLevel(RandomRange(50, 54));

  StartXP := XPBar.Read();
  HunterLevel := Stats.GetLevel(ERSSkill.HUNTER);

  RawMeat := 'Raw bird meat';
  BirdSnare := 'Bird snare';
  Bones := 'Bones';
  Feather := 'Orange feather';

  BirdSnareSetupCol2 := CTS2(4288403, 28, 0.06, 0.46);
  SprungSnareCol := CTS2(5868968, 13, 0.02, 0.70);

end;

procedure TAntiban.Setup(); override;
begin
  Self.Skills := [ERSSkill.Total];
  Self.Skills := [ERSSkill.HUNTER];
  Self.MinZoom := 45;
  Self.MaxZoom := 55;

  inherited;
end;

procedure TScript.doAction();
begin
  //Self.PickupSnaresBeforeBreak();
  Self.State := Self.getState();
  //WriteLn('Current state: ', Self.State);

  case Self.State of
    EState.CLEAR_INV: Self.ClearInv();
    EState.CHECK_SNARE: Self.CheckSnare();
    EState.SETUP_SNARE: Self.SetupSnare();
    EState.WALK_NEWSPOT: Self.WalkNewSpot();
    EState.BURY_BONES: Self.BuryBones();
  end;

end;

procedure TScript.Run(MaxActions: Int32; MaxTime: Int64);
begin
  Self.Init(MaxActions, MaxTime);
  if RSClient.IsLoggedIn() then
  repeat
    self.doAction();
  until false;
end;

function TScript.MaxTraps(): Int32;
begin
  if HunterLevel < 20 then
    Result := 1
  else if HunterLevel < 40 then
    Result := 2
  else if HunterLevel < 60 then
    Result := 3
  else if HunterLevel < 80 then
    Result := 4
  else
    Result := 5;
end;

function TScript.WalkNewSpot(): Boolean;
var
  targetPoint: TPoint;
begin
  targetPoint := BirdAreaPoly.RandomValue();

  if (targetPoint.x >= 0) and (targetPoint.y >= 0) then
  begin
    WriteLn('New target point: ', targetPoint.x, ', ', targetPoint.y); // Debug statement
    RSW.WalkPath([targetPoint]);
    Result := True;
    Exit;
  end;

  Result := False;
end;

function TScript.SetupSnare(): Boolean;
var
  trapPoints: TPointArray;
  SnareBox: TBox;
  i: Int32;
  newSnare: Snare;
begin
  Repeat
    MyPos := Self.RSW.GetMyPos();
    for i := 0 to High(Self.Snares) do
    Self.MoveAwayFromSnare(i);
    WriteLn('Setting up bird snare');
    Inventory.HoverItem('Bird snare');
    Wait(700);
    if Mainscreen.IsUpText(['Bird snare']) then
    begin
      Mouse.Click(MOUSE_LEFT);
      Wait(800); // Seems to be a delay in Chat read, increase if we have issues
      if Chat.FindLastMessage('lay', [CHAT_COLOR_BLACK]) then
      begin
        WriteLn('Cannot lay snare here, moving to a new location');
        Self.RandomWalkFromCurrentPos();
        Minimap.WaitPlayerMoving();
        break;
      end;

      SetLength(Self.Snares, Self.SnareCount + 1);
      newSnare.Position := Self.RSW.GetMyPos();
      newSnare.State := SETUP;
      Self.Snares[Self.SnareCount] := newSnare;
      SnareBox := Self.RSW.GetTileMS(Self.Snares[Self.SnareCount].Position).Bounds().Expand(3);

      while not Minimap.IsPlayerMoving() do
        Sleep(Random(100, 150));

      Minimap.WaitPlayerMoving();
      Inc(Self.SnareCount);
      WriteLn('Number of traps: ', Self.SnareCount, ' / ', MaxTraps());
    end;
    if Self.SnareCount >= MaxTraps() then
      Break;
  until (not Inventory.ContainsItem('Bird snare')) or (Self.SnareCount = 0);
  if not Inventory.ContainsItem('Bird snare') and (Self.SnareCount = 0) then
  begin
    Logout.ClickLogout;
    TerminateScript('No bird snares and no traps laid. Logging out');
  end;
end;

// Probly an easier way to findlastmessage in SRL but I couldn't find it quickly so here we are...
function TRSChat.FindLastMessage(Message: String; Colors: TIntegerArray = CHAT_MESSAGE_COLORS): Boolean;
begin
  if Message in Self.GetMessage(CHAT_INPUT_LINE - 1, Colors) then
    Exit(True);    

  Exit(False);
end;

procedure TScript.RandomWalkFromCurrentPos();
var
  NewPos, OldPos: TPoint;
  Attempts, Range, DirectionX, DirectionY, i, j: Int32;
  isSnarePosition: Boolean;
begin
  Attempts := 0;
  Range := 5;
  DirectionX := 1;
  DirectionY := 1;
  repeat
    Minimap.WaitPlayerMoving();
    OldPos := Self.RSW.GetMyPos();
    NewPos := OldPos;
    NewPos.x := NewPos.x + DirectionX * RandomRange(-Range, Range);
    NewPos.y := NewPos.y + DirectionY * RandomRange(-Range, Range);

    // This is a fail safe to keep us near the snares, UNTESTED.
    for i := 0 to High(Self.Snares) do
    begin
      if (Abs(NewPos.x - Self.Snares[i].Position.x) > 15) or (Abs(NewPos.y - Self.Snares[i].Position.y) > 15) then
      begin
        WriteLn('New position is too far from a snare, trying again');
        Continue;
      end;
    end;

    RSW.WalkPath([NewPos]);
    Minimap.WaitPlayerMoving();
    NewPos := Self.RSW.GetMyPos();
    if (NewPos.x = OldPos.x) and (NewPos.y = OldPos.y) then
    begin
      Inc(Attempts);
      if Mainscreen.DidRedClick() then
      begin
        DirectionX := -DirectionX;
        DirectionY := -DirectionY;
      end;
    end
    else
      Attempts := 0;
    if Attempts >= 2 then
    begin
      Inc(Range, 5);
      Attempts := 0;
    end;
  until (NewPos.x <> OldPos.x) or (NewPos.y <> OldPos.y);

  // Check if the new position is a snare position
  isSnarePosition := False;
  for j := 0 to High(Self.Snares) do
  begin
    if (NewPos.x = Self.Snares[j].Position.x) and (NewPos.y = Self.Snares[j].Position.y) then
    begin
      isSnarePosition := True;
      Break;
    end;
  end;

  // An extra failsafe to make sure our new location isn't a snare location.
  if isSnarePosition then
    Self.RandomWalkFromCurrentPos();
end;

// Probably an easier way to do this but this should help find if the bar has fallen
// Shoutout to Flight who talked about doing the method this way in discord.
function Middle(const Arr: TPointArray): TPoint;
var
  i, SumX, SumY: Int32;
begin
  SumX := 0;
  SumY := 0;
  for i := 0 to High(Arr) do
  begin
    SumX := SumX + Arr[i].X;
    SumY := SumY + Arr[i].Y;
  end;
  Result.X := SumX div Length(Arr);
  Result.Y := SumY div Length(Arr);
end;

procedure TScript.CheckSnare();
var
  i: Int32;
  SnareTPA, SuccessTPA, FailTPA, SprungTPA: TPointArray;
  SnareBox: TBox;
  SnareMiddle, SprungMiddle: TPoint;
  snareHandled: Boolean;
begin
  Self.MoveAwayFromSnare(i);
  for i := 0 to Length(Self.Snares) - 1 do
  begin
    snareHandled := False;
    if (i >= 0) and (i < Length(Self.Snares)) then
    begin
      SnareBox := Self.RSW.GetTileMS(Self.Snares[i].Position).Bounds().Expand(20);
      if SRL.FindColors(SnareTPA, BirdSnareSetupCol2, SnareBox) > 0 then
      begin
        if Chat.FindLastMessage('fallen over', [CHAT_COLOR_BLACK]) then
        begin
          Self.HandleBrokenSnare(SnareTPA, i);
        end
        else if SRL.FindColors(SuccessTPA, SuccessSnareCol, SnareBox) > 0 then
        begin
          Self.HandleSuccessfulSnare(SuccessTPA[0], i);
          snareHandled := True;
          // This is an extra fail safe, sometimes a bird would fly near but just break the snare
          if SRL.FindColors(SuccessTPA, SuccessSnareCol, SnareBox) = 0 then
          begin
            Self.HandleBrokenSnare(SnareTPA, i);
          end;
        end
        else if SRL.FindColors(SprungTPA, SprungSnareCol, SnareBox) > 0 then
        begin
          SnareMiddle := Middle(SnareTPA);
          SprungMiddle := Middle(SprungTPA);
          if SprungMiddle.y > SnareMiddle.y then
          begin
            Self.HandleBrokenSnare(SnareTPA, i);
            snareHandled := True;
          end;
        end;
      end;
      if snareHandled then
        break;
    end;
  end;

  if Self.SnareCount < Self.MaxTraps() then
    Self.SetupSnare();
end;

procedure TScript.PickupSnaresBeforeBreak();
var
  i: Int32;
  SnareTPA: TPointArray;
  SnareBox: TBox;
begin
  // Check if a break is due in the next minute
  if (Antiban.Breaks[0].NextAtTime - GetTimeRunning()) < 60000 then
  begin
    // If a break is due, pick up all snares
    for i := 0 to Length(Self.Snares) - 1 do
    begin
      SnareBox := Self.RSW.GetTileMS(Self.Snares[i].Position).Bounds().Expand(10);
      if SRL.FindColors(SnareTPA, BirdSnareSetupCol2, SnareBox) > 0 then
      begin
        Self.HandleBrokenSnare(SnareTPA, i);
      end;
    end;
  end;
end;

procedure TScript.HandleFallenSnare(SnareTPA: TPointArray; fallenSnareIndex: Int32; i: Int32 = 0);
var
  SnareMiddle: TPoint;
begin
  SnareMiddle := Middle(SnareTPA);
  WriteLn('Handling Fallen Snare');
  Mouse.Move(SnareMiddle);
  if Mainscreen.IsUpText(['Take']) then
  begin
    Mouse.Click(MOUSE_LEFT);
    Minimap.WaitPlayerMoving();
    Wait(randomRange(800, 1300)); 
    Self.Snares[fallenSnareIndex] := Self.Snares[High(Self.Snares)];
    SetLength(Self.Snares, Length(Self.Snares) - 1);
    Self.MoveAwayFromSnare(i);
  end;
end;

procedure TScript.HandleSuccessfulSnare(successPoint: TPoint; i: Int32);
var
  MyPos, OffsetPoint: TPoint;
  Attempts: Int32;
begin
  Attempts := 0;

  repeat
    // Since we are finding a small part of the snare, this makes the click a little more random
    OffsetPoint := Point(successPoint.x + RandomRange(1, 3), successPoint.y + RandomRange(-1, 3));
    Mouse.Move(OffsetPoint);

    if Mainscreen.IsUpText('Check') then
    begin
      Mouse.Click(MOUSE_LEFT);
      WaitUntil(Chat.FindLastMessage('caught, [CHAT_COLOR_BLACK]'), 100, 5000);
      Dec(Self.SnareCount);
      Inc(Self.SuccessfulCatches);
      Self.Snares[i] := Self.Snares[High(Self.Snares)];
      SetLength(Self.Snares, Length(Self.Snares) - 1);
      Self.MoveAwayFromSnare(i);
      Break;
    end;

    Inc(Attempts);
  until Attempts >= 4;
end;

procedure TScript.RemoveSnare(i: Int32);
begin
  Dec(Self.SnareCount);
  Self.Snares[i] := Self.Snares[High(Self.Snares)];
  SetLength(Self.Snares, Length(Self.Snares) - 1);
  if Self.SnareCount = 0 then
  begin
    Exit;
  end;
end;

procedure TScript.HandleBrokenSnare(SnareTPA: TPointArray; brokenSnareIndex: Int32);
var
  SnareMiddle, OffsetPoint: TPoint;
  Attempts: Int32;
begin
  SnareMiddle := Middle(SnareTPA);
  Attempts := 0;

  repeat
    OffsetPoint := Point(SnareMiddle.x + RandomRange(-1, 4), SnareMiddle.y + RandomRange(-1, 4));
    Mouse.Move(OffsetPoint);

    if Mainscreen.IsUpText(['Dismantle', 'Take']) then
    begin
      Mouse.Click(MOUSE_LEFT);
      Minimap.WaitPlayerMoving();
      WaitUntil(Chat.FindLastMessage('dismantle', [CHAT_COLOR_BLACK]), randomRange(100, 200), randomRange(4000, 6000));
      RemoveSnare(brokenSnareIndex);
      Break;
    end;

    Inc(Attempts);
  until Attempts >= 3; // Adjust this number based on how many attempts you want to make
end;

function TScript.MoveAwayFromSnare(i: Int32): Boolean;
var
  MyPos: TPoint;
begin
  Minimap.WaitPlayerMoving();
  MyPos := Self.RSW.GetMyPos();
  Result := (i >= 0) and (i < Length(Self.Snares)) and (MyPos.x = Self.Snares[i].Position.x) and (MyPos.y = Self.Snares[i].Position.y);
  if Result then
  begin
    WriteLn('We are in a snare position, Moving!');
    Self.RandomWalkFromCurrentPos();
  end;
end;

// This code works great, a little slow maybe we can speed it up, Future Plan.
// This code is adapated from Slacky's BuryBones in the discord. Shoutout to Slacky
procedure TScript.BuryBones();
var
  BonesSlots, BonesPattern: TIntegerArray;
  Bone, i: Int32;
begin
  if Inventory.FindItem('Bones', BonesSlots) then
  begin
    // Build pattern:
    for i := 0 to High(BonesSlots) do
      BonesPattern += BonesSlots[i];

    // Bury each bone
    for Bone in BonesPattern do
    begin
      Inventory.ClickSlot(Bone);
      WaitUntil(not Inventory.IsSlotUsed(Bone), 50, 2000);
      Wait(260, 550, wdLeft);
      Inc(Self.BonesBuried);
      WriteLn('Number of bones buried: ', BonesBuried);
    end;
  end;
end;

procedure TScript.ClearInv();
var
  dropItems: TRSItemArray;
begin
  // Hardcoded BuryBones to True fix this when we finally do the gui
  if True then
    Self.BuryBones();

  // Define the items to drop
  dropItems := ['Raw bird meat'];

  // Commented out GUI-related code
  // if not GUI.KeepFeathers.Checked then
  //   Add(dropItems, 'Orange feather');

  if not Inventory.ShiftDrop(dropItems, DROP_PATTERN_SNAKE) then

  Wait(randomRange(90, 300));

  if Self.ShouldCheckSnare() then
    Self.State := EState.CHECK_SNARE;
end;

function TScript.ShouldClearInv(): Boolean;
begin
  Inventory.Open(); // Had to call this first since CountEmpty wasn't reporting correct value
  Wait(randomRange(80, 100)); // Had to add a little delay here because sometimes CountEmpty wouldn't report correctly.
  if Inventory.CountEmptySlots() <= 3 then
  Exit(True);
end;

function TScript.ShouldSetupSnare(): Boolean;
begin
  Exit((not SRL.PointInPoly(Self.RSW.GetMyPos(), Self.BirdAreaPoly)) and (Self.SnareCount < Self.MaxTraps));
end;

function TScript.ShouldWalkNewSpot(): Boolean;
begin
  Exit((not SRL.PointInPoly(Self.RSW.GetMyPos(), Self.BirdAreaPoly)) and (Self.SnareCount = 0));
end;

function TScript.ShouldCheckSnare(): Boolean;
var
  i: Int32;
  SnareTPA: TPointArray;
  SnareBox: TBox;
begin
  if Self.SnareCount = 0 then
    Exit(False);

  for i := 0 to Length(Self.Snares) - 1 do
  begin
    SnareBox := Self.RSW.GetTileMS(Self.Snares[i].Position).Bounds().Expand(10);

    if (SRL.FindColors(SnareTPA, BirdSnareSetupCol2, SnareBox) > 0) or
       (SRL.FindColors(SnareTPA, SuccessSnareCol, SnareBox) > 0) or
       (SRL.FindColors(SnareTPA, SprungSnareCol, SnareBox) > 0) then
      Exit(True);
  end;

  Exit(False);
end;

function TScript.GetState(): EState;
begin
  if (not RSClient.IsLoggedIn) then Exit;

  if Self.ShouldWalkNewSpot() then
    Exit(EState.WALK_NEWSPOT);

  if Self.ShouldClearInv() then
    Exit(EState.CLEAR_INV);

  if Self.ShouldCheckSnare() then
    Exit(EState.CHECK_SNARE);

  if Self.ShouldSetupSnare() then
    Exit(EState.SETUP_SNARE);

  // Default state
  Exit(EState.SETUP_SNARE);
end;

var
  Script: TScript;

{$IFDEF SCRIPT_GUI}
type
  TConfig = record(TScriptForm)
    Selector, BirdSelector: TLabeledCombobox;
    BuryBonesCheckBox, DropFeathersCheckBox: TLabeledCheckBox;
  end;

procedure TConfig.BirdChanger(Sender: TObject);
var
  selectedBird: string;
begin
  selectedBird := Self.BirdSelector.GetText();

  if selectedBird = 'Crimson Swift LVL 1' then
  begin
    Script.BirdAreaPoly := [[0000, 0000], [0000, 0000], [0000, 0000], [0000, 0000]];
    Script.SuccessSnareCol := CTS2(111111, 9, 0.02, 0.18);
  end
  else if selectedBird = 'Golden Warbler LVL 5' then
  begin
    Script.BirdAreaPoly := [[0001, 0001], [0001, 0001], [0001, 0001], [0001, 0001]];
    Script.SuccessSnareCol := CTS2(2222222, 9, 0.02, 0.18);
  end
  else if selectedBird = 'Copper Longtail LVL 9' then
  begin
    Script.BirdAreaPoly := [[4624, 2056], [4656, 2054], [4662, 2099], [4640, 2099]]; 
    Script.SuccessSnareCol := CTS2(3038871, 9, 0.02, 0.18);
  end
  else if selectedBird = 'Cerulean Twitch LVL 11' then
  begin
    Script.BirdAreaPoly := [[0002, 0002], [0002, 0002], [0002, 0002], [0002, 0002]];
    Script.SuccessSnareCol := CTS2(3333333, 9, 0.02, 0.18);
  end
  else if selectedBird = 'Tropical Wagtail LVL 19' then
  begin
    Script.BirdAreaPoly := [[0003, 0003], [0003, 0003], [0003, 0003], [0003, 0003]];
    Script.SuccessSnareCol := CTS2(444444, 9, 0.02, 0.18);
  end
end;

procedure TConfig.StartScript(sender: TObject); override;
begin
  BURYBONES := Self.BuryBonesCheckBox.IsChecked();
  DROPFEATHERS := Self.DropFeathersCheckBox.IsChecked();
  inherited;
end;

procedure TConfig.Run(); override;
var
  tab: TTabSheet;
begin
  Self.Setup("BigAussie Bird Snarer");
  Self.Start.SetOnClick(@Self.StartScript);

  Self.AddTab('Script Settings');
  tab := Self.Tabs[High(Self.Tabs)];

  Self.CreateAccountManager(tab);

  Self.CreateVersionPanel(tab);

  Self.CreateAntibanManager();

  Self.CreateWaspLibSettings();
  
  Self.CreateAPISettings();

with Self.BirdSelector do
begin
  Create(tab);
  SetCaption('Bird:');
  SetLeft(TControl.AdjustToDPI(30));
  SetTop(TControl.AdjustToDPI(135));
  SetStyle(csDropDownList);
  AddItemArray(['Crimson Swift LVL 1', 'Golden Warbler LVL 5', 'Copper Longtail LVL 9', 'Cerulean Twitch LVL 11', 'Tropical Wagtail LVL 19']);
  SetItemIndex(0);
  Combobox.SetOnChange(@Self.BirdChanger); // Thanks Torwent Woodcutter for this method
end;

  with Self.BuryBonesCheckBox do
  begin
    Create(tab);
    SetCaption("Bury Bones");
    SetLeft(TControl.AdjustToDPI(30));
    SetTop(Self.BirdSelector.GetTop() + TControl.AdjustToDPI(50));
    SetChecked(BURYBONES);
  end;
  
  with Self.DropFeathersCheckBox do
  begin
    Create(tab);
    SetCaption("Drop Feathers");
    SetLeft(TControl.AdjustToDPI(30));
    SetTop(Self.BuryBonesCheckBox.GetTop() + TControl.AdjustToDPI(20));
    SetChecked(DROPFEATHERS);
  end;

//  with Self.SpeedBarLabel do
//  begin
//    Create(tab);
//    SetTop(Self.PrayCheckBox.GetTop() + TControl.AdjustToDPI(30));
//    SetLeft(TControl.AdjustToDPI(125));
//    SetCaption('Script Speed:');
//  end;
//
//  with Self.SpeedBar do
//  begin
//    Create(tab);
//    SetMin(0);
//    SetMax(110);
//    SetPosition(SCRIPTSPEED);
//    SetWidth(TControl.AdjustToDPI(250));
//    SetLeft(TControl.AdjustToDPI(30));
//    SetTop(Self.SpeedBarLabel.GetTop() + TControl.AdjustToDPI(15));
//    SetTooltip('Script Speed');
//  end;
//
//  with Self.SpeedBarLabel2 do
//  begin
//    Create(tab);
//    SetTop(Self.SpeedBar.GetTop() + TControl.AdjustToDPI(20));
//    SetLeft(TControl.AdjustToDPI(25));
//    SetCaption('Slow                          Medium                Fast    Turbo');
//  end;
//
//  with Self.AnimeCheckBox do
//  begin
//    Create(tab);
//    SetCaption("Based Progress Report");
//    SetLeft(TControl.AdjustToDPI(30));
//    SetTop(Self.SpeedBarLabel2.GetTop() + TControl.AdjustToDPI(30));
//    SetChecked(BASED);
//  end;

  inherited;
end;

var
  Config: TConfig;
{$ENDIF}

begin
  {$IFDEF SCRIPT_GUI}
  Sync(@Config.Run);
  {$ENDIF}
  Script.Run(WLSettings.MaxActions, WLSettings.MaxTime);
end.
{$DEFINE CJ_BIRDHOUSE_RUNNER}
{$IFNDEF WL_OSR}
  {$I WaspLib/osr.simba}
{$ENDIF}
{$IFNDEF ANDREW_MUSHTREE_INCLUDED}
  {$I WaspLib/optional/interfaces/mainscreen/mushtree.simba}
{$ENDIF}
{$IFNDEF SKUNK_UNIVERSAL_TRANSPORT}
  {$I Includes\WaspLib\optional\handlers\teleports\transport.simba}
{$ENDIF}
var
  BHWriteDebug : Boolean := true;

type

  ERSLogType = (
    REGULAR_LOGS, OAK_LOGS, WILLOW_LOGS, TEAK_LOGS, MAPLE_LOGS, MAHOGANY_LOGS, YEW_LOGS, MAGIC_LOGS, REDWOOD_LOGS
  );

  EScriptState = (DO_NOTHING, TELEPORTING, NAVIGATING, CLICK_MUSHROOM, USE_MUSHROOM, BUILD_BIRDHOUSE, INTERACT_BIRDHOUSES );
  EScriptAfterState = (NOTHING, WALK_BANK, WITHDRAW_NEXT_RUN, TAKING_BOAT, WALK_MUSHROOM, TELEPORT_MUSHROOM, FINISHED );
  ERSMushroomLocation = (VERD_VALLEY, HILL_HOUSE, SHROOM_MEADOW); //Names have been changed to protect the globals of the same name

  TBirdhouse = record
    BirdhouseObject : TRSObject;
    IsFilled : Boolean;
  end;

  TMushroom = record
    Mushroom : TRSObject;
    location : ERSMushroomLocation;
  end;

  CurrBirdhouse = ^TBirdhouse;

  TBirdHouseInclude = record
    LogType, SuggestedLogType : ERSLogType;
    Seed : TRSItem;
    BirdHousesFilled : Int8;
    VerdValleySouthBirdHouse, VerdValleyNorthBirdHouse, MushMeadowBirdhouse, TarBirdHouse : TBirdhouse;
    CampRowBoat : TRSObject;

    TaskInterval : Uint32;

    CurrentBirdHouse : CurrBirdhouse;
    HasRunStarted, HasRunFinished,
    ShouldTeleport, TakenRowBoat,
    AlwaysUseBestLog, TerminateOnNoLogs, Initialized : Boolean;

    RSW : TRSWalker;
    ScriptIntervalTimer : TCountdown;
    VerdValleyShroom, MushMeadowShroom, HouseHillShroom : TRSObject;
    MushIndex : Int8;
    RunsCompleted : Int32;
    NestsLooted : Int32;
    RunStartXp, TotalXPEarned : UInt64;
    Mushrooms : array of TMushroom;
    birdHouses : array of TBirdhouse;
    State : EScriptState;
    EndScriptState : EScriptAfterState;
  end;

var
  BirdHouseRunner : TBirdHouseInclude;

function TMushroom.GetMushButton() : ERSMushTreeButton;
begin
  case Self.location of
    ERSMushroomLocation.HILL_HOUSE : Result := ERSMushTreeBUtton.VERDANT_VALLEY;
    ERSMushroomLocation.VERD_VALLEY : Result := ERSMushTreeBUtton.MUSHROOM_MEADOW;
    ERSMushroomLocation.SHROOM_MEADOW : Result := ERSMushTreeBUtton.HOUSE_ON_THE_HILL;
  end;
end;

function TRSMushTree.Click(mushroom : ERSMushTreeButton) : Boolean;
begin
  Result := Self.GetButton(mushroom).Click();
end;

function TBirdHouseInclude.GetNewRunInterval() : Uint64;
begin
  Result := Round(Random(Self.TaskInterval * 1.043598435, Self.TaskInterval * 1.35))
end;

procedure TBirdHouseInclude.DebugLn(message : string);
begin
  if not BHWriteDebug then
    Exit;

  WriteLn(SRL.TimeStamp() + ':[' + 'BirdhouseRunner' + ']: ' + message);
end;

function TBirdHouseInclude.GetBirdHouseSpace() : TPointArray;
const
  SPACE_COLOR : TCTS2Color := CTS2(9029, 1, 0.01, 0.01); //CTS2(1192279, 8, 0.17, 4.86);
var
  ATPA : T2DPointArray;
  msC : TPoint := Mainscreen.Center();
begin
  SRL.FindColors(Result, SPACE_COLOR, Mainscreen.Bounds());
  Result := Result.Grow(3);
  ATPA := Result.Cluster(10);
  ATPA := ATPA.SortFrom(msC);

  if ATPA.Len() < 1 then
    Result := []
  else
    Result := ATPA[0];
end;

function TBirdHouseInclude.GetLogString(log : ERSLogType) : string;
begin
  case log of
    ERSLogType.REGULAR_LOGS : Result := "Logs";
    else
      Result := ToStr(Log).Before("_") + " logs";
  end;
end;

function TBirdHouseInclude.GetBirdhouseItem(log : ERSLogType) : TRSItem;
var
  baseBirdHouse : TRSItem := "Bird house";

begin
  case log of
    ERSLogType.REGULAR_LOGS : Result := baseBirdHouse;
    else
      Result := ToStr(Log).Before("_") + " " + baseBirdHouse;
  end;
end;

function TBirdHouseInclude.GetWithdrawList() : TRSBankItemArray;
begin
  Result += TRSBankItem.Setup("Chisel", 1, false);
  Result += TRSBankItem.Setup("Hammer", 1, false);
  Result += TRSBankItem.Setup(Self.GetLogString(Self.LogType), 4, false);
  Result += TRSBankItem.Setup("Clockwork", 1, false);
  Result += TRSBankItem.Setup(Self.Seed, 40, false);
end;

function TRSBank.FindAll(items: TRSItemArray): Boolean; overload;
var
  tempBox : TBox;
  i : Int32;
  tempItem : TRSBankItem;

begin
  for i := 0 to High(items) do
  begin
    tempItem.Item := items[i];
    if not Self.FindItem(tempItem, tempBox) then
      Exit(false);
  end;

  Result := true;
end;

function TRSBankItemArray.ToItemArray() : TRSItemArray; constref;
var
  i : Int32;

begin
  for i := 0 to High(Self) do
  begin
    Result += Self[i].Item;
  end;
end;

function TBirdHouseInclude.HasTools() : Boolean;
var
  tools : TRSItemArray;
  i : Int32;
begin

  if Inventory.ContainsItem(Self.GetBirdhouseItem(Self.LogType)) then
    Exit(true);

  //Can't count seeds while the slot is selected.
  if Inventory.GetSelectedSlot() = -1 then
    Exit(true);

  tools := ['Chisel', 'Hammer'];

  if (not Inventory.ContainsItem(Self.GetLogString(Self.LogType))
  or not Inventory.ContainsItem('Clockwork')) then
  begin
    Self.DebugLn("Missing birdhouse, log, or clockwork");
    Exit(false);
  end;

  for i := 0 to High(tools) do
  begin
    if not Inventory.ContainsItem(tools[i]) then
    begin
      Self.DebugLn("Missing item: " + ToStr(tools[i]));
      Exit(false);
    end;
  end;

  i := Inventory.CountItemStack(Self.Seed);
  Result :=  i >= 5;
  if not Result then
    Self.DebugLn("Seed count: " + ToStr(i));

end;

procedure TBirdHouseInclude.SetupBirdHouses();
var
  VVBHN, VVBHS, MMBHN, TARBH : TRSObject;
  commonFinder : TRSObjectFinder;

begin
  //Regular
  commonFinder.ColorClusters += [CTS2(1789275, 5, 0.10, 0.69), CTS2(6201021, 8, 0.03, 1.40), 20];
  //Oak
  commonFinder.ColorClusters += [CTS2(5074823, 15, 0.05, 0.33), CTS2(8561589, 7, 0.04, 1.08), 20];
  //Willow
  commonFinder.ColorClusters += [CTS2(2314071, 7, 0.06, 0.42), CTS2(3366502, 7, 0.06, 1.61), 20];
  //Teak
  commonFinder.ColorClusters += [CTS2(3495271, 9, 0.12, 0.20), CTS2(6848914, 4, 0.31, 0.40), 20];
  //Maple
  commonFinder.ColorClusters += [CTS2(2774407, 5, 1.08, 0.39), CTS2(2774923, 3, 0.01, 0.01), 20];
  //Mahogany
  commonFinder.ColorClusters += [CTS2(1065831, 3, 0.15, 1.31), CTS2(3425125, 4, 0.10, 0.33), 20];
  //Yew
  commonFinder.ColorClusters += [CTS2(11332, 3, 0.08, 0.01), CTS2(476757, 7, 0.19, 2.44), 20];
  //Magic
  commonFinder.ColorClusters += [CTS2(7962919, 9, 0.03, 0.29), CTS2(10922399, 14, 0.12, 0.17), 20];
  //Redwood
  commonFinder.ColorClusters += [CTS2(604522, 8, 0.22, 2.05), CTS2(4154261, 6, 0.05, 0.13), 20];
  commonFinder.ClusterDistance := 10;

  with VVBHN do
  begin
    SetupCoordinates([ [9471, 1252] ]);
    SetupUpText(['act', 'irdHouse']);
    ShapeArray.SetShape([2, 2, 6]);
    Finder := commonFinder;
    Filter.MinimapDot := false;
  end;

  with VVBHS do
  begin
    SetupCoordinates([ [9446, 1276] ]);
    SetupUpText(['act', 'irdHouse']);
    ShapeArray.SetShape([2, 2, 6]);
    Finder := commonFinder;
    Filter.MinimapDot := false;
  end;

  with MMBHN do
  begin
    SetupCoordinates([ [9107, 769] ]);
    SetupUpText(['act', 'irdHouse']);
    ShapeArray.SetShape([2, 2, 6]);
    Finder := commonFinder;
    Filter.MinimapDot := false;
  end;

  with TARBH do
  begin
    SetupCoordinates([ [9114, 1034] ]);
    SetupUpText(['act', 'irdHouse']);
    ShapeArray.SetShape([2, 2, 6]);
    Finder := commonFinder;
    Filter.MinimapDot := false;
  end;

  Self.VerdValleyNorthBirdHouse := [VVBHN, false];
  Self.VerdValleySouthBirdHouse := [VVBHS, false];
  Self.MushMeadowBirdhouse := [MMBHN, false];
  Self.TarBirdHouse := [TARBH, false];
end;

function TBirdHouseInclude.GetHouseOnHillRegion() : TBox;
begin
  Result := Box(10024, 865, 10314, 1114)
end;

function TBirdHouseInclude.GetNearestUnfilledBirdHouse(myPos : TPoint; out bestIndex : Int32) : Boolean;
var
  dist : Int32;
  bestDist : Int32 = 99999;
  i : Int8;
begin
  for i := 0 to High(Self.birdHouses) do
  begin
    if Self.birdHouses[i].IsFilled then
      continue;

    dist := Distance(Self.birdHouses[i].BirdhouseObject.Coordinates[0], myPos);

    if dist < bestDist then
    begin
      bestDist := dist;
      bestIndex := i;
      Result := true;
    end;
  end;
end;

procedure OnWalkEvent(Sender: PRSWalker; Position: TPoint; Destination: TPoint);
begin

  if Sender <> @BirdhouseRunner.RSW then
    exit;

  if not Inventory.ContainsItem(BirdHouseRunner.GetBirdhouseItem(BirdHouseRunner.LogType)) then
  begin
    BirdHouseRunner.BuildBirdHouseItem();
  end;

  Position := [];
  Destination := [];
end;

procedure TBirdHouseInclude.Init();
var
  VerdValleyShroom, MushMeadowShroom, HouseHillShroom : TMushroom;
begin
  Writeln("Birdhouse runner init!");
  Self.RSW.SetupRegions([RSRegions.FOSSIL_ISLAND, Self.GetHouseOnHillRegion()]);
  Self.RSW.AdaptiveWalk := true;
  Self.RSW.AdaptiveToggleDistances := Point(10, 10);
  Self.RSW.OnWalkingEvent := @OnWalkEvent;
  //HideMyInfo();

  with HouseHillShroom.Mushroom do
  begin
    Setup(16, [ [10158, 948] ]);
    SetupUpText(['Mushtree']);
    Finder.Colors += CTS2(3233415, 13, 0.19, 0.65);
    Finder.Colors += CTS2(4339785, 11, 0.18, 0.52);
    Finder.ColorClusters += [CTS2(3233415, 13, 0.19, 0.65), CTS2(7176299, 39, 0.05, 0.19), 30];
    Finder.ColorClusters += [CTS2(3233415, 13, 0.19, 0.65), CTS2(5605773, 38, 0.05, 0.59), 30];
  end;

  with VerdValleyShroom.Mushroom do
  begin
    Setup(16, [[9426, 1272]]);
    SetupUpText(['Mushtree']);
    Finder.Colors += CTS2(3233415, 13, 0.19, 0.65);
    Finder.Colors += CTS2(4339785, 11, 0.18, 0.52);
    Finder.ColorClusters += [CTS2(3233415, 13, 0.19, 0.65), CTS2(7176299, 39, 0.05, 0.19), 30];
    Finder.ColorClusters += [CTS2(3233415, 13, 0.19, 0.65), CTS2(5605773, 38, 0.05, 0.59), 30];
  end;

  with MushMeadowShroom.Mushroom do
  begin
    Setup(16, [ [9106, 812] ]);
    SetupUpText(['Mushtree']);
    Finder.Colors += CTS2(3233415, 13, 0.19, 0.65);
    Finder.Colors += CTS2(4339785, 11, 0.18, 0.52);
    Finder.ColorClusters += [CTS2(3233415, 13, 0.19, 0.65), CTS2(7176299, 39, 0.05, 0.19), 30];
    Finder.ColorClusters += [CTS2(3233415, 13, 0.19, 0.65), CTS2(5605773, 38, 0.05, 0.59), 30];
  end;

  with Self.CampRowBoat do
  begin
    Setup(2.5, 3, [[9295, 1068]]);
    SetupUpText(['Travel']);
    Finder.Colors += CTS2(6190723, 1, 0.01, 0.01);
    Finder.Colors += CTS2(3819600, 13, 0.09, 0.20);
  end;

  HouseHillShroom.location := ERSMushroomLocation.HILL_HOUSE;
  VerdValleyShroom.location := ERSMushroomLocation.VERD_VALLEY;
  MushMeadowShroom.location := ERSMushroomLocation.SHROOM_MEADOW;

  Self.Mushrooms := [HouseHillShroom, VerdValleyShroom, MushMeadowShroom];
  Self.MushIndex := 0;

  Self.ShouldTeleport := true;

  SetupBirdHouses();
  Self.birdHouses := [Self.VerdValleyNorthBirdHouse, Self.VerdValleySouthBirdHouse, Self.MushMeadowBirdhouse, Self.TarBirdHouse];
  Self.Initialized := true;

  Self.DebugLn("Birdhouse Run initialized");
  Self.DebugLn("Log: " + ToStr(Self.LogType));
  Self.DebugLn("Seed: " + ToStr(Self.Seed));
  Self.DebugLn("UseBestLog? : " + ToStr(Self.AlwaysUseBestLog));
  Self.DebugLn("Interval: " + SRL.MsToTime(Self.TaskInterval, TTimeFormat.Time_Formal));

  if Self.ScriptIntervalTimer.Length < 100 then
  begin
    Self.ScriptIntervalTimer.Init(Self.GetNewRunInterval());
    Self.DebugLn("Started timer from Init");
  end;
end;

function TBirdHouseInclude.GetClosestObject(evalObjects : TRSObjectArray; position : TPoint ) : TRSObject;
var
  bestDist : Int32 := 99999;
  dist : Int32 := 99999;
  i : Int8;

begin
 Result := evalObjects[0];
 dist := Distance(position, evalObjects[0].Coordinates[0]);

 for i := 0 to High(evalObjects) do
 begin
  dist := Distance(position, evalObjects[i].Coordinates[0]);

  if dist < bestDist then
  begin
    bestDist := dist;
    Result := evalObjects[i];
  end;
 end;
end;

function TBirdHouseInclude.ConfirmUptext(textToCheck : TStringArray) : Boolean;
const
  TEXT_COLOR : TCTS0Color := CTS0(14014992, 20);
var
  tpa : TPointArray;
begin
  Result := (Mainscreen.IsUpText(textToCheck))
             and (SRL.FindColors(tpa, TEXT_COLOR, MainScreen.UpTextArea) > 0);
end;

function TBirdHouseInclude.DismantleBirdhouse() : Boolean;
var
  birdhouseATPA : T2DPointArray;
  dismantleTimeout : TCountDown;
begin

  Self.DebugLn("Moving");
  if not WaitUntil(Self.RSW.WalkBlind(Self.CurrentBirdHouse^.BirdhouseObject.Coordinates[0], 20), 150, 5000) then
    Exit;

  WaitUntil(not Minimap.IsPlayerMoving(), 50, 5000);
  Self.DebugLn("Done Moving");

  if not Inventory.ContainsItem(BirdHouseRunner.GetBirdhouseItem(BirdHouseRunner.LogType)) then
  begin
    BirdHouseRunner.BuildBirdHouseItem();
  end;

  dismantleTimeout.Init(6000);

  while not dismantleTimeout.IsFinished() do
  begin
    birdHouseATPA := CurrentBirdHouse^.BirdhouseObject.FindOnMainScreen(CurrentBirdHouse^.BirdhouseObject.GetCuboidArray());

    if birdHouseATPA.Len() < 1 then
    begin
      Antiban.RandomRotate();
      Self.DebugLn("Failed to find bird house, rotating");
      continue;
    end;

    birdHouseATPA := birdHouseATPA.SortFrom(MainScreen.Center());

    Mouse.Move(birdHouseATPA[0].RandomValue());

    if not Self.ConfirmUptext(['nteract']) then
    begin
      Antiban.RandomRotate();
      continue;
    end;

    Mouse.Click(MOUSE_RIGHT);
    Self.DebugLn("Dismantling birdhouse");

    if WaitUntil(ChooseOption.IsOpen, 100, 1200) then
    begin
      if ChooseOption.Select(['mpty'], MOUSE_LEFT, false, true)
        and WaitUntil(XPBar.EarnedXP(), 100, 8000) then
      begin
        Result := WaitUntil(Length(Self.GetBirdHouseSpace()) > 1, 200, 2000);
        if Result then
        begin
          Self.DebugLn("Cleared this birdhouse");
          Exit(Result);
        end;
      end;
    end;
  end;
end;

//At this point we should have a birdhouse in the inventory that we can use.
function TBirdHouseInclude.InteractWithBirdHouseSpace() : Boolean;
var
  birdhouseATPA : T2DPointArray;
  birdHouseSpaceTPA : TPointArray;
  BirdSpaceTimeout : TCountDown;

begin

  Self.DebugLn("Interacting with space");

  BirdSpaceTimeout.Init(4000);
  while not BirdSpaceTimeout.IsFinished() do
  begin
    birdHouseSpaceTPA := Self.GetBirdHouseSpace();

    if birdHouseSpaceTPA.Len() < 1 then
    begin
      Antiban.RandomRotate();
      continue;
    end;

    Mouse.Move(birdHouseSpaceTPA.RandomValue());

    if not Mainscreen.IsUpText(['uild', 'pace']) then
    begin
      Antiban.RandomRotate();
      continue;
    end;

    Self.DebugLn("Found space");
    Mouse.Click(MOUSE_LEFT);

    if WaitUntil(not Inventory.ContainsItem(Self.GetBirdhouseItem(Self.LogType)), 200, 2300) then
    begin
      BirdSpaceTimeout.Pause();
      break;
    end;
  end;

  if BirdSpaceTimeout.IsFinished() then
    Exit(false);

  //If we click the space so we need to make sure we're not moving and we've found our current birdhouse.
  if WaitUntil(not Minimap.IsPlayerMoving()
      and ((Mainscreen.IsUpText(['eeds', 'mpty'])) or (Self.CurrentBirdHouse^.BirdhouseObject.Find(birdhouseATPA))), 75, 8000) then
    Result := true;
end;

function TBirdHouseInclude.FillBirdHouse() : Boolean;
var
  birdhouseATPA : T2DPointArray;
  seedSlot, seedCount : Int32;
  timeout : TCountdown;
begin
  if not Inventory.FindItem(Self.Seed, seedSlot) then
  begin
    TerminateScript("No seeds!");
  end;

  seedCount := Inventory.CountItemStack(Self.Seed);

  while not Inventory.IsSlotSelected(seedSlot) do
  begin
    Inventory.SetSelectedSlot(-1);
    Inventory.SetSelectedSlot(seedSlot);
    Wait(100);
  end;

  timeOut.Init(6500);
  Self.DebugLn("Attempting to fill birdhouse");
  while not timeout.IsFinished() do
  begin
    birdHouseATPA := CurrentBirdHouse^.BirdhouseObject.FindOnMainScreen(CurrentBirdHouse^.BirdhouseObject.GetCuboidArray());

    if birdHouseATPA.Len() < 1 then
    begin
      Antiban.RandomRotate();
      continue;
    end;

    birdHouseATPA := birdHouseATPA.SortFrom(Mainscreen.Center());
    Mouse.Move(birdhouseATPA[0].RandomValue());

    if Self.ConfirmUptext(['mpty']) then
    begin
      timeout.Pause();
      Mouse.Click(MOUSE_LEFT);
      break;
    end;

    Antiban.RandomRotate();
    Wait(Random(110, 210));
  end;

  if timeout.IsFinished() then
  begin
    Writeln("Timed out on filling, skipping this birdhouse");
    Self.CurrentBirdHouse^.IsFilled := true;
    Self.BirdHousesFilled += 1;
    Exit;
  end;

  Result := WaitUntil(seedCount > Inventory.CountItemStack(Self.Seed), 100, 6000);
end;

function TBirdHouseInclude.HandleBirdHouse() : Boolean;
begin
  //There's already a birdhouse there and should be ready for dismantling
  //Find our current birdhouse and interact with it.
  //Dismantle and return once there's a space.
  if Self.DismantleBirdhouse() then
  begin
    Self.DebugLn("Dismantled our current birdhouse " + ToStr(Self.CurrentBirdHouse^.BirdhouseObject));
    WaitUntil(Length(Self.GetBirdHouseSpace()) > 1, 200, 4000);
  end;

  Wait(Random(313, 523));

  //Check for a space and build a birdhouse there.
  if Self.InteractWithBirdHouseSpace() then
  begin
    Self.DebugLn("Built new birdhouse " + ToStr(Self.CurrentBirdHouse^.BirdhouseObject));
  end;

  Wait(Random(241, 456));

  if Self.FillBirdHouse() then
  begin
    Self.DebugLn("Filled birdhouse " + ToStr(Self.CurrentBirdHouse^.BirdhouseObject));
    Self.CurrentBirdHouse^.IsFilled := true;
    Self.BirdHousesFilled += 1;
    Result := true;
  end;
end;

function TBirdHouseInclude.BuildBirdHouseItem() : Boolean;
var
  birdHouseItem : TRSItem := Self.GetBirdhouseItem(Self.LogType);

begin
  if not Inventory.ContainsItem('Clockwork')
    and not Inventory.ContainsItem(birdHouseItem) then
  begin
    TerminateScript('We lack the items to keep birdhousing');
  end;

  if not Inventory.ContainsItem(birdHouseItem) then
  begin
    Self.DebugLn("No birdhouse in inventory, making one");

    if not Inventory.Use('Chisel', Self.GetLogString(Self.LogType)) then
    begin
      Self.DebugLn("Failed to use chisel");
      Exit;
    end;

    if WaitUntil(Make.IsOpen(), 100, 1200) then
    begin
      if not Make.Select(ToStr(birdHouseItem), Make.QUANTITY_ALL, Antiban.BioDice()) then
      begin
        Self.DebugLn("Failed to make birdHouse");
        Exit;
      end;
    end;

    if not WaitUntil(Inventory.ContainsItem(Self.GetBirdhouseItem(Self.LogType)), 100, 3000) then
    begin
      Self.DebugLn("Inventory has no birdHouse");
      Exit;
    end;

    Result := true;
  end;
end;

function TBirdHouseInclude.GetBirdhouseFillCount() : Int32;
var
  i : Int32;
begin
  for i := 0 to High(Self.birdHouses) do
  begin
    if Self.birdHouses[i].IsFilled then
      Inc(Result);
  end;
end;

procedure TBirdHouseInclude.Reset()
var
  i : Int32;

begin
  Self.MushIndex := 0;
  Self.BirdHousesFilled := 0;
  Self.CurrentBirdHouse := nil;
  Self.ShouldTeleport := true;
  Self.TakenRowBoat := false;

  for i := 0 to High(Self.birdHouses) do
  begin
    Self.birdHouses[i].IsFilled := false;
  end;
end;

function TBirdHouseInclude.GetState() : EScriptState;
var
  myPos : TPoint := RSW.GetMyPos();
  bestBHIndex : Int32 := -1;

begin

  if Self.HasRunFinished then
  begin
    Exit(EScriptState.DO_NOTHING);
  end;

  if Self.GetBirdhouseFillCount() = 4 then
  begin
    Self.DebugLn("Run finished");
    Inc(Self.RunsCompleted);
    Self.TotalXPEarned += XPBar.Read() - Self.RunStartXp;
    Self.NestsLooted += Inventory.CountItem('Bird nest');
    if WaitUntil(Chat.HasContinue(), 150, 1400) then
      Chat.ClickContinue(true);

    Self.HasRunFinished := true;
    Self.Reset();
    Exit(EScriptState.DO_NOTHING);
    //TerminateScript("Finished run");
  end;

  //Check if we got our tools
  if not Self.HasTools() then
  begin
    Self.HasRunFinished := true;
    Self.Reset();
    Self.DebugLn("Ending run: Missing some tools");
    Exit(EScriptState.DO_NOTHING);
  end;

  if (Self.GetNearestUnfilledBirdHouse(myPos, bestBHIndex))
    and (bestBHIndex > -1 ) then
  begin
    Self.CurrentBirdHouse := @Self.birdHouses[bestBHIndex];

    if myPos.DistanceTo(Self.CurrentBirdHouse^.BirdhouseObject.Coordinates[0]) < 100 then
    begin
      Self.ShouldTeleport := false;
      Exit(EScriptState.INTERACT_BIRDHOUSES);
    end;

    Self.ShouldTeleport := true;
  end;

  if Self.MushIndex = High(Self.Mushrooms) then
    Exit(EScriptState.NAVIGATING);

  if Self.ShouldTeleport then
  begin
    if Self.MushIndex < High(Self.Mushrooms) then
    begin
      Self.CurrentBirdHouse := nil;

      if MushTree.IsOpen() then
        Exit(EScriptState.USE_MUSHROOM);

      Exit(EScriptState.CLICK_MUSHROOM);
    end;
  end;
end;

function TBirdHouseInclude.WalkToMushroom(index : Int32 = -1) : Boolean;
var
  indexToUse : Int32;

begin
  if index = -1 then
    indexToUse := Self.MushIndex
  else
    indexToUse := index;

  if not Self.Mushrooms[indexToUse].Mushroom.WalkClick() then
    Self.Debugln("Failed to get to mushroom")
  else
    Result := WaitUntil(Mushtree.IsOpen(), 300, 10000);
end;

function TBirdHouseInclude.HandleMushroomTeleport(index : Int32 = -1) : Boolean;
var
  mushroomBox : TBox;
  indexToUse : Int32;
begin

  if not MushTree.IsOpen() then
    Exit;

  if index = -1 then
    indexToUse := Self.MushIndex
  else
    indexToUse := index;

  Mushtree.Click(Self.Mushrooms[indexToUse].GetMushButton());

  mushroomBox := Box(Self.Mushrooms[indexToUse].Mushroom.Coordinates[0], 100, 100);

  if WaitUntil(not mushroomBox.Contains(Self.RSW.GetMyPos()), 400, 6000) then
  begin
    Self.DebugLn("Successfully teleported to mushroom");
    Result := true;
    if index = -1 then
      Self.MushIndex := Min(MushIndex + 1, High(Self.Mushrooms));

    Self.DebugLn("Mush index now: " + ToStr(Self.MushIndex));
    //Basically waiting for screen to fade in.
    Wait(Random(1400, 2200));
  end;
end;

function TBirdHouseInclude.HandleNavigating() : Boolean;
begin
  Result := Self.RSW.WebWalk(Self.CurrentBirdHouse^.BirdhouseObject.Coordinates[0]);
end;

function TBirdHouseInclude.GetLogForHunterLevel(level : Int32) : ERSLogType;
begin
  if level >= 89 then
    Result := ERSLogType.REDWOOD_LOGS
  else if level >= 74 then
    Result := ERSLogType.MAGIC_LOGS
  else if level >= 59 then
    Result := ERSLogType.YEW_LOGS
  else if level >= 49 then
    Result := ERSLogType.MAHOGANY_LOGS
  else if level >= 44 then
    Result := ERSLogType.MAPLE_LOGS
  else if level >= 34 then
    Result := ERSLogType.TEAK_LOGS
  else if level >= 24 then
    Result := ERSLogType.WILLOW_LOGS
  else if level >= 14 then
    Result := ERSLogType.OAK_LOGS
  else
    Result := ERSLogType.REGULAR_LOGS;
end;

function TRSBank.FindAny(items: TRSItemArray): Boolean; overload;
var
  tempBox : TBox;
  i : Int32;
  tempItem : TRSBankItem;

begin
  for i := 0 to High(items) do
  begin
    tempItem.Item := items[i];
    if Self.FindItem(tempItem, tempBox) then
      Exit(true);
  end;
end;

function TBirdHouseInclude.GetNextBestLogInBank(currLog : ERSLogType) : ERSLogType;
var
  i : Int32;
  tempBox : TBox;
  foundBankItem : TRSBankItem;
begin
  if not Bank.IsOpen() then
    Exit(Self.LogType);

  i := Ord(currLog);

  for i downto 0 do
  begin
    foundBankItem.Item := Self.GetLogString(ERSLogType(i));

    if Bank.FindItem(foundBankItem, tempBox) then
      Exit(ERSLogType(i));
  end;

  Self.DebugLn("Couldn't find any other logs");
  TerminateScript("Out of logs");
end;

function TBirdHouseInclude.WalkToIslandBank() : Boolean;
begin
  if Self.AlwaysUseBestLog then
    Self.SuggestedLogType := Self.GetLogForHunterLevel(Stats.GetLevel(ERSSkill.HUNTER));

  Result := Bank.WalkOpen(RSObjects.BankChestFossilIsland);
end;

//Function responsible for getting to a bank
//Probably switching gear
//Withdrawing the needed things
//Should return if it was successful
function TBirdHouseInclude.OnStart() : Boolean;
begin
  Exit(true);
end;

procedure TBirdHouseInclude.OnComplete();
begin
  Exit;
end;

function TBirdHouseInclude.HasAllItemsForRun() : Boolean;
var
  tools : TRSBankItemArray;
  i : Int32;
  itemStr : string;
begin

  tools := Self.GetWithdrawList();

  for i := 0 to High(tools) do
  begin
    itemStr := ToStr(tools[i].Item);
    if itemStr.Contains("seed") then
    begin
      if Inventory.CountItemStack(tools[i].Item) < 40 then
      begin
        Self.DebugLn("Cannot do run, missing some seeds");
        Exit(false);
      end;
    end
    else
    begin
      if Inventory.CountItem(tools[i].Item) < tools[i].Quantity then
      begin
        Self.DebugLn("Cannot do run, not enough of item: " + itemStr);
        Exit(false);
      end;
    end;
  end;

  Result := true;
end;

function TBirdHouseInclude.TeleportToIsland() : Boolean;
var
  transporter: TUniversalTransport;
begin
  Result := transporter.Run(RSTEleports.FOSSIL_ISLAND);
  if not Result then
    Self.DebugLn("Could not teleport");
end;

function TBirdHouseInclude.GetReportStrings() : TStringArray;
const
  spacingStart : string := "[";
  spacingEnd : string := "|]";
var
  listOfStrings : TStringArray;
  i : Int32;
begin
  listOfStrings += spacingStart + "=================================" + spacingEnd;
  listOfStrings += "Birdhouse Include by CJ";
  listOfStrings += spacingStart + "=================================" + spacingEnd;
  listOfStrings += "Runs Completed: " + ToStr(Self.RunsCompleted);
  listOfStrings += "XP Earned: " + ToStr(Self.TotalXPEarned);
  listOfStrings += "Nests Looted: " + ToStr(Self.NestsLooted);
  listOfStrings += spacingStart + "=================================" + spacingEnd;

  //Header text
  Result += listofStrings[0];
  Result += spacingStart + PadL(" ", 3, " ") + PadR(listofStrings[1], 30, " ") + spacingEnd;
  Result += listofStrings[2];

  for i := 3 to High(listOfStrings) - 1 do
  begin
    Result += spacingStart + PadL(" ", 3, " ") + PadR(listOfStrings[i], 30, " ") + spacingEnd;
  end;

  Result += listOfStrings[High(listOfStrings)];
end;

procedure TBirdHouseInclude.DisplayReport();
var
  report : TStringArray;
  i : Int32;
begin
  report := Self.GetReportStrings();
  for i := 0 to High(report) do
  begin
    Writeln(report[i]);
  end;
end;

//These 3 functions together look dumb
//But it's actually so authors can do something like
//procedure TBirdHouseInclude.PrintReport() override;
//PrintMainScriptReport()
//inherited;
//As a way to append it.
procedure TBirdHouseInclude.PrintReport();
begin
  Self.DisplayReport();
end;

procedure TBirdHouseInclude.BirdhouseRun();
var
  CachedWalker : PRSWalker;

begin
  CachedWalker := ScriptWalker;

  if not Self.Initialized then
  begin
    Self.Init();
  end;

  if not Self.OnStart() then
    Exit;

  ScriptWalker := @Self.RSW;

  if (not GetHouseOnHillRegion().Contains(Self.RSW.GetMyPos()))
    and not (Self.TeleportToIsland()) then
  begin
    Writeln("Not in hill region!");
    Exit;
  end;

  Self.RunStartXp := XPBar.Read();

  while not Self.HasRunFinished do
  begin
    //Re-log in during run
    if not RSClient.IsLoggedIn() then
    begin
      if not Login.LoginPlayer() then
      begin
        TerminateScript("Could not log in player");
      end;
    end;

    Self.State := Self.GetState();

    if Self.State <> EScriptState.DO_NOTHING then
      Self.DebugLn("SciptState: " + ToStr(Self.State));

    case Self.State of
      EScriptState.BUILD_BIRDHOUSE : Self.BuildBirdHouseItem();
      EScriptState.INTERACT_BIRDHOUSES : Self.HandleBirdHouse();
      EScriptState.CLICK_MUSHROOM : Self.WalkToMushroom();
      EScriptState.USE_MUSHROOM : Self.HandleMushroomTeleport();
      EScriptState.TELEPORTING : ;
      EScriptState.DO_NOTHING : ;
      EScriptState.NAVIGATING : Self.HandleNavigating();
    end;
  end;

  Self.HasRunFinished := false;

  Self.PrintReport();

  //Responsible for getting them back to their initial activity
  ScriptWalker := CachedWalker;
  Self.OnComplete();
end;

function TBirdHouseInclude.CanDoBirdHouseRun() : Boolean;
begin
  if not Self.ScriptIntervalTimer.IsFinished() then
  begin
    WriteLn('Next birdhouse run in ' + SRL.MsToTime(Self.ScriptIntervalTimer.TimeRemaining(), TTimeFormat.Time_Formal_Long));
    Exit(false);
  end;

  Result := true;
end;

procedure TBirdHouseInclude.DoBirdHouseRun();
begin
  Self.BirdhouseRun();

  if(Self.TaskInterval < (50 * ONE_MINUTE)) then
    Self.TaskInterval := 50 * ONE_MINUTE;

  Self.ScriptIntervalTimer.Init(Self.GetNewRunInterval());
end;

function TBirdHouseInclude.WithdrawNextRun() : Boolean;
var
  itemList : TRSBankItemArray;
  i, itemNumNeeded : Int32;
  itemName : string;
  nextBestLog : ERSLogType;
  transporter: TUniversalTransport;

begin
  if not Bank.IsOpen() then
    Exit;

  if Self.AlwaysUseBestLog
  and not Self.TerminateOnNoLogs
  and (Self.LogType <> Self.SuggestedLogType) then
  begin
    if not Bank.FindAll([Self.GetLogString(Self.LogType), Self.GetLogString(Self.SuggestedLogType)]) then
    begin
      Self.DebugLn("Bank doesn''t have our best choice or current choice, finding another");
      nextBestLog := Self.GetNextBestLogInBank(Self.LogType);
      Self.DebugLn("Next best log is: " + ToStr(nextBestLog) + " changing our current log: " + ToStr(Self.LogType) + " to this one");
      Self.LogType := nextBestLog;
    end
    else if Self.LogType <> Self.SuggestedLogType then
    begin
      Self.DebugLn("Updated current log type: " + ToStr(Self.LogType) + " to best type: " + ToStr(Self.SuggestedLogType));
      Self.LogType := Self.SuggestedLogType;
    end;
  end;

  itemList := Self.GetWithdrawList();

  for i := 0 to High(itemList) do
  begin
    itemName := ToStr(itemList[i].Item);
    if not itemName.Contains('seed') then
      itemNumNeeded := itemList[i].Quantity - Inventory.CountItem(itemList[i].Item)
    else
    begin
      itemNumNeeded := itemList[i].Quantity - Max(0, Inventory.CountItemStack(itemList[i].Item));
    end;

    if itemNumNeeded < 1 then
    begin
      Self.DebugLn("Skipping withdraw for item: " + ToStr(itemList[i].Item));
      continue;
    end;

    itemList[i].Quantity := itemNumNeeded;
    if not Bank.WithdrawItem(itemList[i], false) then
    begin
      Self.DebugLn("Bank is missing: " + ToStr(itemList[i].Item));
      Exit(false);
    end;

    if not WaitUntil(Inventory.ContainsItem(itemList[i].Item), 100, 2000) then
    begin
      Self.DebugLn("Could not withdraw item: " + ToStr(itemList[i].Item));
      Exit(false);
    end;
  end;

  if not transporter.withdrawTeleportItem(RSTeleports.FOSSIL_ISLAND) then
  begin
    Self.DebugLn("Could not get pendant");
    Exit(false);
  end;

  Result := true;
end;

//If you don't use the GUI's TScriptForm.CreateBirdhouseRunSettings
//Use this to set the values directly.
procedure TBirdHouseInclude.Setup(log : ERSLogType; seedItem : TRSItem; useBestLog : Boolean = false; interval : UInt32 = (50 * ONE_MINUTE));
begin
  with Self do
  begin
    LogType := log;
    Seed := seedItem;
    AlwaysUseBestLog := useBestLog;
    TaskInterval := interval;
  end;

  Writeln("SETUP INTERVAL: ", ToStr(Self.TaskInterval));
  Self.ScriptIntervalTimer.Init(Self.GetNewRunInterval());
  Writeln("SETUP birdhouse run in: ", SRL.MsToTime(Self.ScriptIntervalTimer.TimeRemaining(), TTimeFormat.Time_Formal_Long));
end;

//If you like GUIs this will set up a tab in your GUI.
function TScriptForm.CreateBirdhouseRunSettings(): TTabSheet;
  type TScriptForm = TScriptForm;

  procedure TScriptForm._BestLogCheckBoxChanged(sender: TObject);
  var
    breaks: TCheckBox;
    checked: Boolean;
  begin
    breaks := sender;
    checked := breaks.IsChecked();
    BirdHouseRunner.AlwaysUseBestLog := checked;
  end;

  procedure TScriptForm._SeedChanged(sender: TObject);
  var
    seed : TEdit;
  begin
    seed := sender;
    BirdHouseRunner.Seed := seed.getText();
  end;

  procedure TScriptForm._LogTypeChanged(sender: TObject);
  var
    combobox: TComboBox;
  begin
    combobox := sender;
    BirdHouseRunner.LogType := ERSLogType(comboBox.getItemIndex());
  end;

  procedure TScriptForm._BHIncludeIntervalEditChanged(sender: TObject);
  var
    edit : TEdit;
    str : string;
    bar : TTrackBar;
    value : UInt64;
  begin
    edit := sender;
    str := edit.getText();

    if (str.Len() < 1) then
      str := '0';

    value := StrToUInt64(str);

    if value > 120 then
      value := 120;

    bar := TScriptForm.Form.GetChild("bhi_bar_interval");
    if bar <> nil then
      bar.setPosition(value);

    BirdHouseRunner.TaskInterval := value * ONE_MINUTE;
  end;

  procedure TScriptForm._BHIncludeBarOnChange(sender: TObject);
  var
    bar: TTrackBar;
    edit: TEdit;
    value: Uint64;
  begin
    bar := sender;
    edit := TScriptForm.Form.GetChild('bhi_interval_edit');
    value := bar.getPosition();
    BirdhouseRunner.TaskInterval := value * ONE_MINUTE;
    edit.SetText(ToStr(value));
  end;

var
  bestLogCheckBox : TLabeledCheckBox;
  logTypeCombo : TLabeledCombobox;
  bar: TTrackBar;
  seedEdit, intervalEdit  : TLabeledEdit;
  fullWidth, w, space, y: Int32;

begin
  Self.AddTab('Birdhouse Settings');
  Result := Self.Tabs[High(Self.Tabs)];

  fullWidth := Self.Size.X;
  space := Floor(fullWidth * 0.1);
  w := fullWidth - (space * 2);
  y := Floor(Self.Size.Y/6);

  with seedEdit do
  begin
    Create(Result);
    SetLeft(Round(w/3));
    SetWidth(Round(w/4));
    SetCaption('Seed:');
    SetName('bh_seed');
    SetMaxLength(17);
    Edit.setOnChange(@Self._SeedChanged);
    BirdHouseRunner.Seed := 'Cabbage seed';
    SetText('Cabbage seed');
  end;

  with bestLogCheckBox do
  begin
    Create(Result);
    SetCaption('Always use best log');
    SetTooltip('Will check your hunter level and change log used to match');
    SetLeft(seedEdit.GetRight() + TControl.AdjustToDPI(10));
    SetTop(seedEdit.Edit.GetBottom());
    SetChecked(BirdHouseRunner.AlwaysUseBestLog);
    CheckBox.setOnChange(@Self._BestLogCheckBoxChanged);
  end;

  with logTypeCombo do
  begin
    Create(Result);
    SetCaption('Log type to use:');
    SetStyle(csDropDownList);
    AddItemArray(['Regular', 'Oak', 'Willow', 'Teak',
                  'Maple', 'Mahogany', 'Yew', 'Magic tree', 'Redwood']);

    BirdHouseRunner.LogType := ERSLogType.MAPLE_LOGS;
    SetItemIndex(Ord(ERSLogType.MAPLE_LOGS));
    Combobox.SetOnChange(@Self._LogTypeChanged);
  end;

  with intervalEdit do
  begin
    Create(Result);
    SetCaption('Run Interval:');
    SetName('bhi_interval');
    SetMaxLength(3);
    SetLeft(logTypeCombo.GetLeft() + TControl.AdjustToDPI(60));
    SetTop(logTypeCombo.GetTop() + TControl.AdjustToDPI(60));
    Edit.setOnKeyPress(@Edit.NumberField);
    Edit.setOnChange(@Self._BHIncludeIntervalEditChanged);
    BirdHouseRunner.TaskInterval := 51 * ONE_MINUTE;
    SetText(ToStr(51));
  end;

  with bar do
  begin
    Create(Result);
    SetName("bhi_bar_interval");
    SetMin(0);
    SetMax(120);
    SetPosition(51);
    setFrequency(10);
    SetWidth(TControl.AdjustToDPI(300));
    SetLeft(logTypeCombo.GetLeft());
    SetTop(intervalEdit.GetBottom() + TControl.AdjustToDPI(10));
    SetTooltip('You can adjust the interval time');
    SetOnChange(@Self._BHIncludeBarOnChange);
  end;
end;